package main

import (
	"bufio"
	"bytes"
	"errors"
	"io"
	"log"
	"net"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/tcpassembly"
	"github.com/google/gopacket/tcpassembly/tcpreader"
	"github.com/vulncheck-oss/go-exploit/db"
)

var (
	// stores the HTTP requests as: map[ip-flow]map[port-flow]=serialized request.
	globalRequestMap = make(map[uint64]map[uint64][][]byte)
	// stores the HTTP responses as: map[ip-flow]map[port-flow]=serialized response.
	globalResponseMap = make(map[uint64]map[uint64][][]byte)
	// 301/302 resolve me map (map[rhost][rport][uri] = req.loc).
	globalNeedLocationResolution = make(map[string]map[int]map[string]string)
)

type httpStreamFactory struct {
	Requests bool
}

// httpStream will handle the actual decoding of http requests.
type httpStream struct {
	net, transport gopacket.Flow
	r              tcpreader.ReaderStream
}

func (h *httpStreamFactory) New(net, transport gopacket.Flow) tcpassembly.Stream {
	hstream := &httpStream{
		net:       net,
		transport: transport,
		r:         tcpreader.NewReaderStream(),
	}
	if h.Requests {
		go hstream.parseRequests()
	} else {
		go hstream.parseResponses()
	}

	return &hstream.r
}

// Attempt to deserialize the buffer as an HTTP request. If that succeeds then store it in the map.
func (h *httpStream) parseRequests() {
	buf := bufio.NewReader(&h.r)
	for {
		req, err := http.ReadRequest(buf)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return
			}

			continue
		}
		defer req.Body.Close()

		if globalRequestMap[h.net.FastHash()] == nil {
			globalRequestMap[h.net.FastHash()] = make(map[uint64][][]byte)
		}
		reqpBuffer := &bytes.Buffer{}
		err = req.Write(reqpBuffer)
		if err != nil {
			return
		}
		globalRequestMap[h.net.FastHash()][h.transport.FastHash()] = append(globalRequestMap[h.net.FastHash()][h.transport.FastHash()], reqpBuffer.Bytes())
	}
}

// Attempt to deserialize the buffer as an HTTP response. If that succeeds then store it in the map.
func (h *httpStream) parseResponses() {
	buf := bufio.NewReader(&h.r)
	for {
		resp, err := http.ReadResponse(buf, nil)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return
			}

			continue
		}
		defer resp.Body.Close()

		if globalResponseMap[h.net.FastHash()] == nil {
			globalResponseMap[h.net.FastHash()] = make(map[uint64][][]byte)
		}
		respBuffer := &bytes.Buffer{}
		err = resp.Write(respBuffer)
		if err != nil {
			return
		}

		globalResponseMap[h.net.FastHash()][h.transport.FastHash()] = append(globalResponseMap[h.net.FastHash()][h.transport.FastHash()], respBuffer.Bytes())
	}
}

func buildMap(filename string, requests bool) bool {
	pcapHandle, err := pcap.OpenOffline(filename)
	if err != nil {
		log.Fatal(err)

		return false
	}

	// this is sort of a wild choice? We are going to rely on Go serialization to find
	// HTTP streams amongst all the streams.
	err = pcapHandle.SetBPFFilter("tcp")
	if err != nil {
		log.Fatal(err)

		return false
	}

	streamFactory := &httpStreamFactory{Requests: requests}
	streamPool := tcpassembly.NewStreamPool(streamFactory)
	assembler := tcpassembly.NewAssembler(streamPool)
	packetSource := gopacket.NewPacketSource(pcapHandle, pcapHandle.LinkType())
	packets := packetSource.Packets()
	ticker := time.Tick(time.Minute)
	for {
		select {
		case packet := <-packets:
			if packet == nil {
				return true
			}
			if packet.NetworkLayer() == nil || packet.TransportLayer() == nil || packet.TransportLayer().LayerType() != layers.LayerTypeTCP {
				continue
			}
			tcp := packet.TransportLayer().(*layers.TCP)
			assembler.AssembleWithTimestamp(packet.NetworkLayer().NetworkFlow(), tcp, packet.Metadata().Timestamp)

		case <-ticker:
			assembler.FlushOlderThan(time.Now().Add(time.Minute * -2))
		}
	}
}

// Attempt to match uri with a stored "need resolution" uri.
func tryResolve(rhost string, rport int, uri string, respBytes []byte) {
	// check to see if this 200 resolves any 302
	_, found := globalNeedLocationResolution[rhost]
	if !found {
		return
	}
	_, found = globalNeedLocationResolution[rhost][rport]
	if !found {
		return
	}

	resolveMe, found := globalNeedLocationResolution[rhost][rport][uri]
	if !found {
		return
	}

	db.CacheHTTPResponse(rhost, rport, resolveMe, respBytes)
	delete(globalNeedLocationResolution[rhost][rport], uri)

	// did resolving this redirect resolve another? let's find out!
	tryResolve(rhost, rport, resolveMe, respBytes)
}

// Look into the global "need resolution" map and see if the current response resolves anything -or-
// add the current response to the resolve map (or obviously do nothing).
func resolveRedirects(req *http.Request, resp *http.Response, rhost string, rport int, respBytes []byte) bool {
	if resp.StatusCode == http.StatusFound || resp.StatusCode == http.StatusMovedPermanently {
		// if we don't have a location, not much we can do
		location := resp.Header.Get("Location")
		if len(location) == 0 {
			return false
		}
		if strings.HasPrefix(location, "http") {
			// if a Location has http://etc/path, then strip it down to just path
			parsedURL, err := url.Parse(location)
			if err != nil {
				return false
			}
			location = parsedURL.Path
		}

		// don't cache this response. resolve it later (hopefully).
		_, ok := globalNeedLocationResolution[rhost]
		if !ok {
			globalNeedLocationResolution[rhost] = make(map[int]map[string]string)
			globalNeedLocationResolution[rhost][rport] = make(map[string]string)
		}
		globalNeedLocationResolution[rhost][rport][location] = req.URL.Path

		return false
	} else if resp.StatusCode == http.StatusOK {
		tryResolve(rhost, rport, req.URL.String(), respBytes)
	}

	return true
}

// Extract the rhost and rport from HTTP request's host field, and shove everything into the db.
func doCache(reqBytes []byte, respBytes []byte) {
	req, err := http.ReadRequest(bufio.NewReader(bytes.NewReader(reqBytes)))
	if err != nil {
		return
	}
	if req.Method != http.MethodGet {
		// ignore anything that isn't an http get
		return
	}

	// use the HTTP host field as rhost and rport in the db
	rhost, rportStr, err := net.SplitHostPort(req.Host)
	if err != nil {
		rhost = req.Host
		rportStr = "80"
	}
	rport, _ := strconv.Atoi(rportStr)

	// Look to see if the response is a 302 redirect and flag it for resolution
	resp, err := http.ReadResponse(bufio.NewReader(bytes.NewReader(respBytes)), req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	if !resolveRedirects(req, resp, rhost, rport, respBytes) {
		return
	}

	db.CacheHTTPResponse(rhost, rport, req.URL.String(), respBytes)
}

// Loop through the global maps, find entries with matching flows, and
// attempt to add them to the database.
func createCacheEntries() {
	for reqIPFlow, reqPortMap := range globalRequestMap {
		for reqPortFlow, requests := range reqPortMap {
			respPortMap, ok := globalResponseMap[reqIPFlow]
			if !ok {
				continue
			}
			responses, ok := respPortMap[reqPortFlow]
			if !ok {
				continue
			}
			if len(requests) < len(responses) {
				// this is somewhat a gamble. We allow for more requests than responses. this
				// can certainly occur via go-exploit generated pcaps if we, for example, hold
				// an HTTP connection open with a reverse shell. But, this could also mean that
				// we aren't actually matching up request -> response correctly. Ultimately,
				// it would be nice to have a more exact solution here.
				continue
			}
			// we have matching requests and responses! Sort through and generate db entries
			for index, reqBytes := range requests {
				if len(responses) > index {
					doCache(reqBytes, responses[index])
				}
			}
		}
	}
}

func DoPCAP(inputFile string) bool {
	// sort the requests into a map
	log.Println("Locating all HTTP requests...")
	buildRequestsOk := buildMap(inputFile, true)
	if !buildRequestsOk {
		return false
	}
	if len(globalRequestMap) == 0 {
		log.Println("Failed to extract any HTTP requests")

		return false
	}

	// sort the responses into a map
	log.Println("Locating all HTTP responses...")
	buildResponsesOk := buildMap(inputFile, false)
	if !buildResponsesOk {
		return false
	}
	if len(globalResponseMap) == 0 {
		log.Println("Failed to extract any HTTP responses")

		return false
	}

	// recombine making HTTP
	log.Println("Generating database entries...")
	createCacheEntries()

	return true
}
