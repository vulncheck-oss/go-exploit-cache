package main

import (
	"bufio"
	"bytes"
	"errors"
	"io"
	"log"
	"net"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"github.com/google/gopacket/tcpassembly"
	"github.com/google/gopacket/tcpassembly/tcpreader"
	"github.com/vulncheck-oss/go-exploit/db"
)

var (
	// stores the HTTP requests as: map[ip-flow]map[port-flow]=serialized request.
	globalRequestMap = make(map[uint64]map[uint64][][]byte)
	// stores the HTTP responses as: map[ip-flow]map[port-flow]=serialized response.
	globalResponseMap = make(map[uint64]map[uint64][][]byte)
)

type httpStreamFactory struct {
	Requests bool
}

// httpStream will handle the actual decoding of http requests.
type httpStream struct {
	net, transport gopacket.Flow
	r              tcpreader.ReaderStream
}

func (h *httpStreamFactory) New(net, transport gopacket.Flow) tcpassembly.Stream {
	hstream := &httpStream{
		net:       net,
		transport: transport,
		r:         tcpreader.NewReaderStream(),
	}
	if h.Requests {
		go hstream.parseRequests()
	} else {
		go hstream.parseResponses()
	}

	return &hstream.r
}

// Attempt to deserialize the buffer as an HTTP request. If that succeeds then store it in the map.
func (h *httpStream) parseRequests() {
	buf := bufio.NewReader(&h.r)
	for {
		req, err := http.ReadRequest(buf)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return
			}

			continue
		}
		defer req.Body.Close()

		if globalRequestMap[h.net.FastHash()] == nil {
			globalRequestMap[h.net.FastHash()] = make(map[uint64][][]byte)
		}
		reqpBuffer := &bytes.Buffer{}
		err = req.Write(reqpBuffer)
		if err != nil {
			return
		}
		globalRequestMap[h.net.FastHash()][h.transport.FastHash()] = append(globalRequestMap[h.net.FastHash()][h.transport.FastHash()], reqpBuffer.Bytes())
	}
}

// Attempt to deserialize the buffer as an HTTP response. If that succeeds then store it in the map.
func (h *httpStream) parseResponses() {
	buf := bufio.NewReader(&h.r)
	for {
		resp, err := http.ReadResponse(buf, nil)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return
			}

			continue
		}
		defer resp.Body.Close()

		if globalResponseMap[h.net.FastHash()] == nil {
			globalResponseMap[h.net.FastHash()] = make(map[uint64][][]byte)
		}
		respBuffer := &bytes.Buffer{}
		err = resp.Write(respBuffer)
		if err != nil {
			return
		}

		globalResponseMap[h.net.FastHash()][h.transport.FastHash()] = append(globalResponseMap[h.net.FastHash()][h.transport.FastHash()], respBuffer.Bytes())
	}
}

func buildMap(filename string, requests bool) bool {
	pcapHandle, err := pcap.OpenOffline(filename)
	if err != nil {
		log.Fatal(err)

		return false
	}

	// this is sort of a wild choice? We are going to rely on Go serialization to find
	// HTTP streams amongst all the streams.
	err = pcapHandle.SetBPFFilter("tcp")
	if err != nil {
		log.Fatal(err)

		return false
	}

	streamFactory := &httpStreamFactory{Requests: requests}
	streamPool := tcpassembly.NewStreamPool(streamFactory)
	assembler := tcpassembly.NewAssembler(streamPool)
	packetSource := gopacket.NewPacketSource(pcapHandle, pcapHandle.LinkType())
	packets := packetSource.Packets()
	ticker := time.Tick(time.Minute)
	for {
		select {
		case packet := <-packets:
			if packet == nil {
				return true
			}
			if packet.NetworkLayer() == nil || packet.TransportLayer() == nil || packet.TransportLayer().LayerType() != layers.LayerTypeTCP {
				continue
			}
			tcp := packet.TransportLayer().(*layers.TCP)
			assembler.AssembleWithTimestamp(packet.NetworkLayer().NetworkFlow(), tcp, packet.Metadata().Timestamp)

		case <-ticker:
			assembler.FlushOlderThan(time.Now().Add(time.Minute * -2))
		}
	}
}

// Extract the rhost and rport from HTTP request's host field, and shove everything into the db.
func doCache(reqBytes []byte, respBytes []byte) {
	req, err := http.ReadRequest(bufio.NewReader(bytes.NewReader(reqBytes)))
	if err != nil {
		return
	}
	if req.Method != http.MethodGet {
		// ignore anything that isn't an http get
		return
	}
	if strings.Contains(req.URL.Path, "?") {
		// ignore anything with parameters, I guess?
		return
	}

	// use the HTTP host field as rhost and rport in the db
	rhost, rportStr, err := net.SplitHostPort(req.Host)
	if err != nil {
		rhost = req.Host
		rportStr = "80"
	}
	rport, _ := strconv.Atoi(rportStr)

	db.CacheHTTPResponse(rhost, rport, req.URL.Path, respBytes)
}

// Loop through the global maps, find entries with matching flows, and
// attempt to add them to the database.
func createCacheEntries() {
	for reqIPFlow, reqPortMap := range globalRequestMap {
		for reqPortFlow, requests := range reqPortMap {
			respPortMap, ok := globalResponseMap[reqIPFlow]
			if !ok {
				continue
			}
			responses, ok := respPortMap[reqPortFlow]
			if !ok {
				continue
			}
			if len(requests) != len(responses) {
				// we can't match up the requests and response so skip it
				continue
			}
			// we have matching requests and responses! Sort through and generate db entries
			for index, reqBytes := range requests {
				doCache(reqBytes, responses[index])
			}
		}
	}
}

func DoPCAP(inputFile string) bool {
	// sort the requests into a map
	buildRequestsOk := buildMap(inputFile, true)
	if !buildRequestsOk {
		return false
	}
	if len(globalRequestMap) == 0 {
		log.Println("Failed to extract any HTTP requests")

		return false
	}

	// sort the responses into a map
	buildResponsesOk := buildMap(inputFile, false)
	if !buildResponsesOk {
		return false
	}
	if len(globalResponseMap) == 0 {
		log.Println("Failed to extract any HTTP responses")

		return false
	}

	// recombine making HTTP
	createCacheEntries()

	return true
}
